## Unity3D学习笔记
兴趣使然，很久以前就想做一款自己的游戏，一方面由于时间不允许，而是惧怕学习的难度，但是最近经常玩游戏，耽误了很多时间，在卸载游戏后突然有种看穿游戏的感觉，加之之前与同学一起用java做过一款大富翁游戏，想着自己其实可以用这些游戏时间来自己做些有价值的事——例如开发一款游戏。
目前开发游戏最流行的就是Unity引擎，一方面可以做游戏，另一方面也可以做动画学渲染等技能。我找到很多资源，最终决定在B站上跟着视频来学习更好些，[感谢Up主的分享，也感谢授课老师幽默的讲解](https://www.bilibili.com/video/BV12s411g7gU)，希望我能一直坚持下来，利用疫情暑假的时间掌握这项技能，做出自己的一款游戏！

### Day 1

#### Unity软件基本使用，基本概念，理解Unity开发架构

* 在新建项目时项目名和项目位置最好时全英文，不要出现汉字，否则可能会出现意想不到的错误意外。
* 在edit菜单里preference菜单里language里可以修改菜单栏显示语言。
* 进入项目后可以通过右上角的Layout菜单改为不同的布局界面，在Project上右键也可以更改project显示的布局。
* Project里放游戏的素材，包括音频，模型什么的。
* Assets里放的（资产），包括项目的model什么的。
* model等资源都可以通过将文件拖到到Unity面板里达到添加的作用。
* Hierarchy面板里放游戏对象，在游戏运行的时候能看见的。
* Scene面板能对游戏对象进行设计操作。
* Game面板能看见游戏真实运行起来用户看起来的效果。
* 鼠标右键移动视野旋转，滚轮滚动视野变近或远(缩放场景)，按下鼠标滚轮拖动场景。
* 选中对象后按`F`键可以让选中对象居中。
* 点击右键同时按下W/S/A/D/Q/E键实现场景漫游
* 按住Alt键同时通过鼠标左键围绕物体旋转场景，鼠标右键缩放场景。
* Inspector检视面板，可以查看修改选中对象的组件(功能)信息。Position参数是选中对象相对世界原点的坐标。鼠标移到X.Y,Z上往左拽或者往右拽也可以进行数值微调，输入的数值可以为简单的四则运算式子。Rotation是对象沿轴旋转的角度，注意XYZ轴的方向。Scale为模型显示比例，一般都为1，1，1
* 点击对象中间的白块可以进行等比例的缩放。
* 按住对象然后Ctrl+D可以进行对象的复制。
* 顶点吸附：选中一个对象，按住V不放，选中其中一个顶点，拖拽移动后松开V键，再松开左键。
* 变换切换：Center，Pivot改变对象的中心点位置，Pivot是美工做的时候确定的中心
* 坐标：Globol全局局视角，Local自身视角
* 中间上部三个图标从左到右为连续播放，暂停和逐帧播放
* 视图的两种模式：ISO——正交视角(平面感觉)，Persp——透视观察模式——3D视角(近大远小)
* 场景Scene(游戏对象的集合)，作为文件储存的时候后缀为.unity,为Unity的图标。Ctrl+S保存的就是场景。Ctrl+N就是新创建一个场景。
* 组件：Transform变换组件决定物体的位置角度比例，Mesh Filter网格过滤器，获取网格信息，Mesh Renderer网格渲染，才能看见。
* 对象在创建的时候默认是在世界坐标的原点创建
* 若要将两个或多个对象捆绑在一起作为一个整体，可以让其中一个作为父对象，其他作为子对象，当移动父对象的时候子对象也跟着一起移动，当然也可以创建一个空的对象让其他所有的对象作为此对象的子对象，这样当父对象移动的时候，同样其余也跟着一起移动，父子对象关系的创建可以直接在Hierarchy窗口通过拖动对象A到对象B实现B作为A的父对象。
* 当建立父子对象关系之后，子对象的position就是相对于父对象的position，而父对象的position仍然是相对世界坐标而言的。当使用空对象作为其余的父对象的时候要确定这个空对象的位置在哪里，因为他是看不见的，在作为判定标准的时候要格外小心。
* 在父子对象捆绑完毕之后给所以子对象全选中，点击右边transform的设置图标，执行reset。让对象transform更新一下，让其都变成与父对象的相对位置。
* 一般让对象都成为空对象的子对象，把对象的行为都绑在父物体上，这样当子对象要更换模型的时候这些行为就不用再更改了。
* material其实本质上是shader的实例，在Project面板右键然后create选项选中material可以创建自己的material，在创建material之后点击自己创建的material，在右边Inspector处有Albedo选项，左面的框就是贴图的地方，右面的框是取色的地方，要进行设置，在设置完毕之后可以将自己的material拖动到想要着色的对象名上，也可以点击想要着色的对象，将material拖动到对象的Mech Renderer组件下的Materials地方。不能将material用于给空的对象着色，因为它没有Mech Renderer组件，不具有materials属性。给对象改颜色其实也可以直接点击对象名，在右边的Albedo直接修改。
* 右边material下有个Rendering Mode渲染模式，一般直接创建的立体是默认的Default Material不允许修改Rendering Mode等，此时就可以用自己创建的Material，这样这些对方就可以选择更改了。右边material下有个Rendering Mode渲染模式，其中cut out选项就指不显示透明通道的渲染，其中Transparent选项就是透明渲染，当然光设置为透明渲染还不行，如果要达到自己需要的透明目标还需要在Albedo处设置A的数值(即透明度)，其中Fade选项就是淡入淡出效果，最后也得在Albedo处设置A的数值(即透明度)。
* Camera组件，作为光锥捕获画面给玩家，Audio Listener组件捕获声音给玩家。
* Camera组件里的Clear Flag就是处理场景的空白部分，其中选项SkyBox天空盒用于包装模拟天空材质，使用天空盒，方式一：Camera中添加组件Skybox，方法二：光照窗口Window-Lighting-Environment Lighting-Skybox，方法二可将天空盒作为反射源将天空颜色反射到物体身上看起来更逼真。
* Camera组件里的Culling Mask里面就是想让摄像机能看见的东西。
* Camera组件里的Projection就是显示的模式，Perspective就是显示有近大远小的3D效果，Orthographic是2D效果。
* 在用Unity的时候突然发现太阳和camera不见了，但是光照和设想画面还在，解决办法：点击Scene面板上的Gizmos，就会显示了
* Camera组件里的Clipping Planes就是视野的调整，Viewport Rect就是摄像画面的显示位置，X,Y是目前的画面坐标，W,H为画面的宽和高，这四个的取值范围都是0~1。
* Camera组件里的Depth数值设置的是渲染的次序，后渲染的会覆盖先渲染的，因此要看见先渲染的Depth值应该比后渲染的Camera组件的Depth值大。因此游戏的小地图Camera应该比Main Camera大，因为小地图Camera应该先渲染。
* 选中物体后Ctrl+Shift+F指定移动后的位置可以迅速移动物体到指定位置。可用于摄像机等的快捷移动。
* 对象的Layer部分可以Add Layer，添加自己设计的层(起个名字就行)，然后选择自己设计的Layer，选择Culling Mask，把自己的层前的勾去掉就可以达到在当前camera不显示这个物体的效果。
* 渲染管线：图形数据在GPU上经过运算处理，最后输出到屏幕上的过程。游戏->图形API->|(CPU与GPU分界线)->顶点处理->图元装配->光栅化->像素处理->缓存，绘制调用Draw Call每次引擎准备数据并通知
GPU的过程，通俗讲，每帧调用显卡渲染物体的次数，要尽量减少Draw Call。
* CPU的顶点处理：接收模型顶点数据，坐标系转换。CPU的图元装配：组装面，连接相邻的顶点,绘制为三角面。CPU光栅化：计算三角面上的像素,并为后面着色阶段提供合理的插值参数。CPU像素处理对每个像素区域进行着色。写入到缓存中。CPU缓存：一个存储像素数据的内存块，最重要的缓存是帧缓存与深度缓存。帧缓存:存储每个像素的色彩,即渲染后的图像。帧缓存常常在显存中, 显卡不断读取并输出到屏幕中。深度缓存z-buffer :存储像素的深度信息,即物体到摄像机的距离。光栅化时便计算各像素的深度值,如果新的深度值比现有值更近，则像素颜色被写到帧缓存,并替换深度缓存。
---------------------------------------------------------
### Day 2

* 即时遮挡剔除Instant Occlusion Culling，遮挡剔除:当物体被送进渲染流水线之前，将摄像机视角内看不到的物体进行剔除,从而减少了每帧渲染数据量, 提高渲染性能。
* 多细节层次Levels of DetailLOD技术指根据物体模型的节点在显示环境中所处的位置和重要度，决定物体渲染的资源分配,降低非重要物体的面数和细节度,从而获得高效率的渲染运算。
* Lighting Setting是在Window-Rendering-Lighting Settings打开。
* 光照系统：  
Global Illumination简称GI ,即全局光照。能够计算直接光、间接光、环境光以及反射光的光照系统。通过GI算法可以使渲染出来的光照效果更为真实丰富。  
Shadow Type阴影类型: Hard 硬阴影、Soft 软阴影、Strength硬度:阴影的黑暗程度。Resolution分辨率:设置阴影的细节程度。Bias偏移: 物体与阴影的偏移。通过Mesh Renderer组件启用禁用阴影 ，Cast /Receive Shadows当前物体是否投射/接收阴影，Off不投射阴影, On投射阴影, Two Sided双面阴影，Shadows Only隐藏物体只投射阴影，阴影剔除:设置显示阴影的距离Edit- > Project Settings- >Quality-> Shadows Disdance
* 环境光照：  
作用于场景内所有物体的光照,通过Environment Lighting中Ambient控制。Ambient Source环境光源，Skybox通过天空盒颜色设置环境光照，Gradient梯度颜色，Sky天空颜色、Equator 地平线颜色、Ground 地面颜色Ambient Color纯色Ambient Intensity环境光强度Ambient GI环境光GI模式Realtime实时更新，环境光源会改变选择此项。Backed烘焙，环境光源不会改变选择此项。
* 反射光照：  
根据天空盒或立方体贴图计算的作用于所有物体的反射效果，通过Environment Lighting中Reflection控制。Reflection Source反射源Skybox天空盒Resolution分辨率Compression 是否压缩Custom自定义
Cubemap立方体贴图Reflection Intensity反射强度Reflection Bounces使用Reflection Probe后允许不同游戏对象间来回反弹的次数。  
* 间接光照：物体表面在接受光照后反射出来的光。通过Light组件中Bounce Intensity反弹强度控制。可以通过Scene面板Irradiance模式查看间接光照。
  注意:
  > 1. 只有标记`Lightmaping Static`的物体才能产生间接反弹光照。
  > 2. 设置间接光照的之前需要将不移动的物体在右面的`Inspector`面板里`static`打上勾作为静态物体。Unity的间接光计算很复杂。
* 实时GI：  
Realtime GI 所谓"实时"是指在运行期间任意修改光源,而所有的变化可以立即更新。正是由于Unity 5引入了行业领先的实时全局光照技术Enlighten系统,才可以在运行时产生间接光照,使场景更为真实丰富。
  操作步骤:
> 1.游戏对象设置为`Lightmaping Static`
> 2.启用`Lighting`面板的`Precomputed Realtime GI`
> 3.点击`Build`按钮(如果勾选Auto编辑器会自动检测场景的改动修复光照效果)
* 在`Edit-preference-GI Cache`可*查看缓存和更改缓存的位置*。
* 烘焙`Lightmap`：
  当场景包含大量物体时,实时光照和阴影对游戏性能有很大影响。使用烘焙技术,可以将光线效果预渲染成贴图再作用到物体上模拟光影,从而提高性能。适用于在性能较低的设备上运行的程序。*设置之前也需要将静止物体设为*`static`，**烘焙只能针对静态的物体**。
* 光源侦测`Light Probes`  
由于`LightMapping`只能作用于`static`物体，所以导致运动的物体与场景中的光线无法融合在一起,显得非常不真实。而`Light Probes`组件可以通过`Probe`收集光影信息,然后对运动物体邻近的几个`Probe`进行插值运算,最后将光照作用到物体上。
* 步骤
> 1.创建游戏对象`Light Probe Group`。
> 2.添加侦测小球`Add Probe`。
> 3.点击`Build`按钮。( 如果勾选`Auto`,编辑器会自动检测
场景的改动修复光照效果)
> 4.勾选需要侦测物体的`MeshRenderer`组件的`Use Light
Probes`属性。  
* 声音：  
  Unity支持的音频文件格式:mp3，ogg，wav,aif,mod,it,s3m,xm。
  声音分为2D、3D两类:
  > 3D声音: 有空间感,近大远小。
  > 2D声音:适合背景音乐。
  在场景中产生声音,主要依靠两个重要组件:
   > `Audio Listener`音频监听器:接收场景中  
   > 音频源`Audio Source`发出的声音，通过计算机的扬声器播放声音。
* Audio Source**音频源**:
> `Audio Clip`音频剪辑:需要播放的音频资源。
> `Mute`静音:如果启用,播放音频没有声音。
> `Play On Awake`唤醒播放:勾选后场景启动时自动播放。
> `Loop`循环:循环播放音频。
> `Volume`音量:音量大小
> `Pitch`音调: 通过改变音调值调节音频播放速度。1是正常播放。
> `Stereo Pan` : 2D声音设置左右声道。
> `Spatial Blend` : 2D与3D声音切换。

---------------------------------------------------------
### C#语言基础

* .NET dotnet
  Microsoft新代多语言的开发平台,用于构建和运行应用程序。
* Mono
  Novell公司支持在其他操作系统下开发.NET程序的框架。
  `Unity`借助`Mono`实现跨平台，核心是`NET Framework`框架
* `namespace`——定义命名空间，类的地址
* `using + 类的命名空间` 相当于其他语言中的`import`库操作
* `Ctrl+A`全选后用`Ctrl+K+F`可以**自动处理缩进**
* 网速10M指的是`Mbps` (兆位/秒)是速率单位,换算成字节应该是`10/8=1.25兆字节/秒`
* C#**数据类型**：
  **整数**：  
  1字节：有符号`sbyte` 无符号`byte`  
  2字节：有符号`short`，无符号`ushort`  
  4字节：有符号`int`，无符号`uint`  
  8字节：有符号`long`，无符号`ulong` 
  浮点数：  
  4字节：`float`  
  8字节：`double`  
  16字节：`decimal`  
  注意事项:  
> 1. 非整形变量赋值*要加上后缀*,如果不加默认为`double`.  
> 2. 浮点型运算会出现*舍入误差*.    
`bool number= 1.0f- 0.9f == 0.1f; ` 
二进制无法精确表示`1/10` ,就像十进制无法精确表示`1/3`,所以二进制表示十进制会有一些*舍入误差*，对于精度要求较高的场合会导致代码的缺陷,可以使用`decimal`代替。  
`decimal`浮点数的后缀是`m` 
非数值类型：  
`char`, `bool`, `string`  
* 建议命名规则:  
以*小写字母*开头,如果包含多个单词,*除第一个单词外其他单词首字母大写*  
* 调试：  
  > 1. 在可能出错的行加断点  
  > 2. 按`F5`**启动**调试  
  > 3. 按`F11`**逐语句**执行
  > 4. 按`Shift+F5`**停止**调试
* 在项目上*右键设为启动项目再进行编辑*
* `Console.WriteLine("金额: {0:c}", 10);`输出: 金额`￥10.00`
* `Console.WriteLine("{0:d2}",5)`输出:` 05`,作用：填充为两位
* `Console.WriteLine("{0:f1}",1.26);`输出:` 1.3`, 保留一位小数  
* `Console.WriteLinet("{0:p0}",0.1);`输出:` 10%`,以百分数显示
* **转义符**也是`\`
* 源代码(`.cs`的文本文件) `CLS`编译- 通用中间语言(`exe dII`)--`CLR`编译---机器码  
* **公共语言运行库**`Common Language Runtime`程序的运行环境,负责内存分配、垃圾收集、安全检查等工作。
* **字符串连接**：字符串可以用`+`连接
* **字符串比较**：可以直接用`==`比较是否相同
* **逻辑运算符** `&&`  `||`  `!`  
* 运算符大部分都和C的语法相同
* **数据类型转换**：  
  `数据类型.Parse(string)`将字符串`string`转换成此数据类型  
  `数据类型.ToString()`将任意类型转换为`string`类型   
* **隐式类型转换(自动转换)**,只能从低字节到高字节类型，**显示类型转换(强制类型转换)**
* `C#`里的`for`循环里可以用`for(int i=0;i<3;i++){}`的形式，支持在`for`循环中用`int i`的形式
* `Random`关键字创建一个随机数，创建格式为`Random random = new Random();int number = random.Next(1,101);`来生成一个`1`到`101`的随机数，**前闭后开**。
* 定义方法:  
 > 访问修饰符+可选修饰符+返回类型+方法名称(参数列表)  
 > {  
 >   //方法体  
 >   //return结果;  
 > }
* 出现报错："*并非所有的代码路径都有返回值*"的原因是方法体中缺少return关键字  
* 强大的**注释方法**：在自己编写的函数之前敲`///`会自动生成注释格式，可以在标签之间书写文字，将来文字会以*提示形式显示在调用方法处
* 在方法名上按`F12`就会*跳到相应方法定义的位置*
* 解决不同参数类型的同一类问题，可以让方法名相同，参数不同，程序会根据方法的参数列表判断是用的哪个方法，让调用者仅仅记忆1个方法，这个就是**方法重载**，同时在调用方法打出括号的时候就会显示有多少个重载的方法，*按上下箭头*可以查看使用各个重载方法
* **递归**，方法调用方法自身来解决问
* 当代码中的一个变量名更改的时候，在这个变量名更改后，按` Ctrl+. `，就可以让*所有原来的这个名字都变成新的名字*，也可以点击左边的提示灯泡，选择重命名**变量的选项**

-------------------------------------------------------------

### Day 3
* **创建数组**的其他方法：
> 1. 初始化+赋值  
> `string[] array01;  
> array01 = new string[2] {"a" ,"b"};`
> 2. 声明+初始化+赋值  
> `bool[]array02 ={true,false,false};`  
* 在数组作为参数传给函数时**创建数组**的快捷方法，例：`float max = GetMax(new float[3]{ 1,3, 7 });`
* C#支持**foreach循环遍历数组**，格式：  
  `foreach(元素类型 变量名 in 数组名称)
   {
      //变量名 即 数组每个元素
   }`  
  局限性:  
  1. 只能读取全部元素(语句本身)  
  2. 不能修改元素  
  3. 只能遍历实现lenumerable接口的集合对象  
  创建foreach循环的快捷方式：  
  `foreach+Tab+Tab`，然后光改变量名  
  生成的模板中var是推断类型(根据所赋数据推断出类型，适用性：数据类型名称较长)
* 用父类可以创建子类数组，声明父类类型赋值子类对象,例：  
  `Array arr01 = new int[2];`  
  当方法的参数是父类时，调用的时候可以将其子类作为参数来调用  
 * object类是万类之祖，所有类型的父类
 * **数组的常用方法及属性**：  
> 数组长度:数组名.Length
> 清除元素值: Array.Clear
> 复制元素: Array.Copy
> 数组名.CopyTo
> 克隆:数组名.Clone
> 查找元素: Array.IndexOf Array.LastIndexOf 
> 排序: Array.Sort
> 反转: Array.Reverse
* C#**创建二维数组**例：
  创建5行3列的二维数组:`int[,] array = new int[5, 3];`
  访问二维数组的元素时也时这种形式，例：第一行第二列元素就是`array[0,1]`
* 在本行用Ctrl+K+Ctrl+C快捷注释掉这一行
* 

----------------------------------------
